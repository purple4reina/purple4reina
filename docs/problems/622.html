<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      622 &middot; Rey Abolofia
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="https://purple4reina.github.io//public/css/poole.css">
  <link rel="stylesheet" href="https://purple4reina.github.io//public/css/syntax.css">
  <link rel="stylesheet" href="https://purple4reina.github.io//public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://purple4reina.github.io//public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://purple4reina.github.io//public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-1a">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Rey Abolofia
        </a>
      </h1>
      <p class="lead">mathematical and programmatic musings with a few cats</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="https://purple4reina.github.io/">Home</a>

      

      
      
        
          
        
      
        
      
        
      
        
      

      <a class="sidebar-nav-item" href="https://github.com/purple4reina">GitHub</a>
      <a class="sidebar-nav-item" href="https://www.linkedin.com/in/rabolofia/">LinkedIn</a>
    </nav>

    <p class="sidebar-copyright">&copy; 2021. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <h1 class="page-title">622</h1>
  <h2 id="comments">Comments</h2>

<p>This problem was a fun one and it wasn’t too hard so I enjoyed it. It
definitely didn’t keep me up all night so that was a plus! I ultimately solved
it in three stages.</p>

<p>Stage one: brute force. First I created a func that given a deck size, would
return the number of shuffles required to put it back to its original state. I
was able to figure out the algorithm for this by doing a little trial and error
on paper. Ends up it has to do with powers of 2 and modulo math. I let this run
overnight (might as well right?) and found it continuing to chug away in the
morning. Doing a bit of math, I found out that I was needing to get through
each number up to 2 to the power of 60! Wow, that’s a big number and definitely
not one you can brute force your way to. So I tried something else.</p>

<p>Stage two: reversing modulo. I had figured out that the algorithm had to do
with modulus math. Instead of brute forcing, I needed to find a way to devise
the answers. This meant reversing the modulo function. In other words, given
<code>a mod b = c</code> we know that the answers are going to be in the form
<code>a = n*b + c</code> where n is an integer. This solves for a, but I wanted to solve
for b which ends up being <code>b = (a - c) / n</code>. I used this formua for a while and
still found it to be incredibly slow.</p>

<p>Stage three: divisors of <code>(a - c)</code>. I looked closer and realized that if n does
not divide <code>(a - c)</code> evenly, then there is no point in trying it. Therefore, I
tried creating a slice of all integers that divide <code>(a - c)</code> evenly and only
trying those. I was worried that creating this divisor slice would take an
insane amount of time. But it didn’t! And eventually I was lead to the answer
in just 19 seconds of program time. Pretty awesome!</p>

<p>Was this my first problem solved in Golang? Maybe! Funtimes!</p>

<h2 id="code">Code</h2>

<pre><code class="language-go">package main

import (
	"fmt"
	"math"
)

// nextLocation gives the next location of a given card location.
func nextLocation(currentLocation, deckSize int) int {
	return (currentLocation * 2) % (deckSize - 1)
}

var (
	overageErr = fmt.Errorf("passed goal shuffle count")
	oddErr     = fmt.Errorf("deck size should not be odd")
)

// shufflesNeeded returns the total shuffles need to return a deck of size
// deckSize back to its original configuration.
func shufflesNeeded(deckSize, goal int) (int, error) {
	if deckSize%2 != 0 {
		return 0, oddErr
	}
	currentLocation := 1
	shuffles := 0
	for {
		shuffles++
		currentLocation = nextLocation(currentLocation, deckSize)
		if currentLocation == 1 {
			return shuffles, nil
		}
		if currentLocation == deckSize-2 {
			return shuffles * 2, nil
		}
		if shuffles &gt; goal {
			return 0, overageErr
		}
	}
}

// getDivisors returns a slice of the divisors of num.
func getDivisors(num int) []int {
	halfWay := int(math.Sqrt(float64(num))) + 1
	d := []int{1, num}
	for i := 2; i &lt; halfWay; i++ {
		if num%i == 0 {
			d = append(d, i)
			if div := num / i; div != i {
				d = append(d, div)
			}
		}
	}
	return d
}

// sumShufflesNeeded returns the total of all deck sizes that are possible to
// shuffler perfectly in goal times.
func sumShufflesNeeded(goal int) int {
	max := int(math.Pow(2, float64(goal))) - 1
	var totalDeckSizes int
	for _, n := range getDivisors(max) {
		i := (max / n) + 1
		if shuffles, _ := shufflesNeeded(i, goal); shuffles == goal {
			totalDeckSizes += i
		}
	}
	return totalDeckSizes
}

func main() {
	result := sumShufflesNeeded(60)
	fmt.Println(result)
}
</code></pre>

<h2 id="tests-and-benchmarks">Tests and Benchmarks</h2>

<pre><code class="language-go">package main

import "testing"

func TestShufflesNeeded(t *testing.T) {
	testcases := []struct {
		deckSize    int
		maxShuffles int
		expected    int
	}{
		{deckSize: 52, maxShuffles: 100, expected: 8},
		{deckSize: 52, maxShuffles: 8, expected: 8},
		{deckSize: 86, maxShuffles: 100, expected: 8},
		{deckSize: 6, maxShuffles: 100, expected: 4},
		{deckSize: 8, maxShuffles: 100, expected: 3},
		{deckSize: 10, maxShuffles: 100, expected: 6},
		{deckSize: 12, maxShuffles: 100, expected: 10},
		{deckSize: 4, maxShuffles: 100, expected: 2},
		{deckSize: 12, maxShuffles: 2, expected: 0},
	}

	for _, test := range testcases {
		if actual, _ := shufflesNeeded(test.deckSize, test.maxShuffles); actual != test.expected {
			t.Errorf("incorrect shufflesNeeded for deck size %d: actual=%d expected=%d",
				test.deckSize, actual, test.expected)
		}
	}
}

func TestSumShufflesNeeded(t *testing.T) {
	testcases := []struct {
		goal     int
		expected int
	}{
		{goal: 3, expected: 8},
		{goal: 4, expected: 22},
		{goal: 5, expected: 32},
		{goal: 6, expected: 96},
		{goal: 7, expected: 128},
		{goal: 8, expected: 412},
		{goal: 9, expected: 586},
		{goal: 10, expected: 1506},
		{goal: 11, expected: 2162},
		{goal: 12, expected: 8628},
		{goal: 13, expected: 8192},
		{goal: 14, expected: 22402},
		{goal: 15, expected: 38878},
		{goal: 16, expected: 111032},
		{goal: 17, expected: 131072},
		{goal: 18, expected: 472936},
		{goal: 19, expected: 524288},
		{goal: 20, expected: 1998354},
		{goal: 21, expected: 2465922},
		{goal: 22, expected: 5907608},
		{goal: 23, expected: 8567138},
		{goal: 24, expected: 38044940},
		{goal: 25, expected: 34713702},
		{goal: 26, expected: 89513986},
		{goal: 27, expected: 155492948},
		{goal: 28, expected: 462252066},
	}

	for _, test := range testcases {
		if actual := sumShufflesNeeded(test.goal); actual != test.expected {
			t.Errorf("incorrect sumShufflesNeeded for goal %d: actual=%d expected=%d",
				test.goal, actual, test.expected)
		}
	}
}

func BenchmarkShufflesNeeded(b *testing.B) {
	b.ReportAllocs()
	for n := 0; n &lt; b.N; n++ {
		shufflesNeeded(52, 8)
	}
}

func BenchmarkSumShufflesNeeded(b *testing.B) {
	b.ReportAllocs()
	for n := 0; n &lt; b.N; n++ {
		sumShufflesNeeded(8)
	}
}
</code></pre>

</div>

    </div>

  </body>
</html>
